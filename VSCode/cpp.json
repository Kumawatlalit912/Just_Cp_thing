{
	"modular": {
		"prefix": "modular",
		"body": [
			"#ifdef int\r",
			"  #undef int\r",
			"#endif\r",
			"\r",
			"template <int MOD_> struct modnum {\r",
			"  static constexpr int MOD = MOD_;\r",
			"  static_assert(MOD_ > 0, \"MOD must be positive\");\r",
			"private:\r",
			"  using ll = long long;\r",
			"  int v;\r",
			"  static int minv(int a, int m) {\r",
			"    a %= m;\r",
			"    assert(a);\r",
			"    return a == 1 ? 1 : int(m - ll(minv(m, a)) * ll(m) / a);\r",
			"  }\r",
			"public:\r",
			"  modnum() : v(0) {}\r",
			"  modnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\r",
			"  explicit operator int() const { return v; }\r",
			"  friend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }\r",
			"  friend std::istream& operator >> (std::istream& in, modnum& n) { ll v_; in >> v_; n = modnum(v_); return in; }\r",
			"  friend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\r",
			"  friend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\r",
			"  modnum inv() const {\r",
			"    modnum res;\r",
			"    res.v = minv(v, MOD);\r",
			"    return res;\r",
			"  }\r",
			"  friend modnum inv(const modnum& m) { return m.inv(); }\r",
			"  modnum neg() const {\r",
			"    modnum res;\r",
			"    res.v = v ? MOD-v : 0;\r",
			"    return res;\r",
			"  }\r",
			"  friend modnum neg(const modnum& m) { return m.neg(); }\r",
			"  modnum operator- () const {\r",
			"    return neg();\r",
			"  }\r",
			"  modnum operator+ () const {\r",
			"    return modnum(*this);\r",
			"  }\r",
			"  modnum& operator ++ () {\r",
			"    v ++;\r",
			"    if (v == MOD) v = 0;\r",
			"    return *this;\r",
			"  }\r",
			"  modnum& operator -- () {\r",
			"    if (v == 0) v = MOD;\r",
			"    v --;\r",
			"    return *this;\r",
			"  }\r",
			"  modnum& operator += (const modnum& o) {\r",
			"    v += o.v;\r",
			"    if (v >= MOD) v -= MOD;\r",
			"    return *this;\r",
			"  }\r",
			"  modnum& operator -= (const modnum& o) {\r",
			"    v -= o.v;\r",
			"    if (v < 0) v += MOD;\r",
			"    return *this;\r",
			"  }\r",
			"  modnum& operator *= (const modnum& o) {\r",
			"    v = int(ll(v) * ll(o.v) % MOD);\r",
			"    return *this;\r",
			"  }\r",
			"  modnum& operator /= (const modnum& o) {\r",
			"    return *this *= o.inv();\r",
			"  }\r",
			"  friend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }\r",
			"  friend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }\r",
			"  friend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\r",
			"  friend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\r",
			"  friend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\r",
			"  friend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\r",
			"  friend string to_string (const modnum& a) { return to_string(int(a)); }\r",
			"};\r",
			"\r",
			"using Mint = modnum<md>;\r",
			"\r",
			"vector<Mint> fact(1, 1);\r",
			"vector<Mint> inv_fact(1, 1);\r",
			"\r",
			"template<class T, class U>\r",
			"T power(const T& a, const U& b) {\r",
			"  assert(b >= 0);\r",
			"  T x = a, res = 1;\r",
			"  U p = b;\r",
			"  while (p > 0) {\r",
			"    if (p & 1) res *= x;\r",
			"    x *= x;\r",
			"    p >>= 1;\r",
			"  }\r",
			"  return res;\r",
			"}\r",
			" \r",
			"Mint C(int n, int k) {\r",
			"  if (k < 0 || k > n) {\r",
			"    return 0;\r",
			"  }\r",
			"  while ((int) fact.size() < n + 1) {\r",
			"    fact.push_back(fact.back() * (int) fact.size());\r",
			"    inv_fact.push_back(1 / fact.back());\r",
			"  }\r",
			"  return fact[n] * inv_fact[k] * inv_fact[n - k];\r",
			"}"
		],
		"description": "Modular arithmetic library"
	},
	"pdbs": {
		"prefix": "pbds",
		"body": [
			"/**\r",
			" * Description: Policy-based data structures that supports normal set operation and\r",
			" *    * find_by_order(k)  returns iterator to kth element starting from 0;\r",
			" *    * order_of_key(k)   returns count of elements strictly [smaller] than k;\r",
			" */\r",
			"\r",
			"template <class T, class cmp = std::less<T>>\r",
			"using ordered_set = tree<T, null_type, cmp, rb_tree_tag,tree_order_statistics_node_update>;\r",
			"\r",
			"template <class key, class value, class cmp = std::less<key>>\r",
			"using ordered_map = tree<key, value, cmp, rb_tree_tag, tree_order_statistics_node_update>;\r",
			"\r",
			"struct custom_hash {\r",
			"  static uint64_t splitmix64(uint64_t x) {\r",
			"    x += 0x9e3779b97f4a7c15;\r",
			"    x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\r",
			"    x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\r",
			"    return x ^ (x >> 31);\r",
			"  }\r",
			" \r",
			"  size_t operator()(uint64_t x) const {\r",
			"    static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\r",
			"    return splitmix64(x + FIXED_RANDOM);\r",
			"  }\r",
			"};\r",
			"\r",
			"template <class key, class val>\r",
			"using hash_map = unordered_map<key, val, custom_hash>;\r",
			"\r",
			"template <class T>\r",
			"using hash_set = unordered_set<T, custom_hash>;\r",
			"\r",
			"template <class key, class val>\r",
			"using hash_table = gp_hash_table<key, val, custom_hash>;"
		],
		"description": "Policy-based data structures"
	},
	"fenwick": {
		"prefix": "fenwick",
		"body": [
			"template <class T>\r",
			"struct fenwick {\r",
			"  vector<T> a;\r",
			"  int n;\r",
			"\r",
			"  fenwick() {}\r",
			"\r",
			"  fenwick(int n_) : n(n_) {\r",
			"    a.resize(n);\r",
			"  }\r",
			"\r",
			"  T query(int r) {\r",
			"    T sum = 0;\r",
			"    for (; r >= 0; r = (r & (r + 1)) - 1) {\r",
			"      sum += a[r];\r",
			"    }\r",
			"    return sum;\r",
			"  }\r",
			"\r",
			"  void add(int idx, T del) {\r",
			"    for (; idx < n; idx = idx | (idx + 1)) {\r",
			"      a[idx] += del;\r",
			"    }\r",
			"  }\r",
			"};"
		],
		"description": "Fenwick tree for prefix sums"
	},
	"Sparse Table": {
		"prefix": "rmq",
		"body": [
			"/**\r",
			" * Description: Computing min/max function in constant time\r",
			" * Source: tourist\r",
			" */\r",
			"\r",
			"template <class T, class F = function<T (const T&, const T&)>>\r",
			"struct SparseTable {\r",
			"  int n;\r",
			"  vector<vector<T>> st;\r",
			"  F func;\r",
			"\r",
			"  SparseTable () {}\r",
			"\r",
			"  SparseTable (const vector<T>& a, const F& f) : func(f) {\r",
			"    n = static_cast<int>(a.size());\r",
			"    int maxlg = 64 - __builtin_clzll(n);\r",
			"    st.resize(maxlg);\r",
			"    st[0] = a;\r",
			"    for (int j = 1; j < maxlg; j++) {\r",
			"      st[j].resize(n - (1 << j) + 1);\r",
			"      for (int i = 0; i <= n - (1 << j); i++) {\r",
			"        st[j][i] = func(st[j-1][i], st[j-1][i + (1 << (j-1))]);\r",
			"      }\r",
			"    }\r",
			"  }\r",
			"\r",
			"  T get (int l, int r) const {\r",
			"    int lg = 64 - __builtin_clzll(r - l + 1) - 1;\r",
			"    return func(st[lg][l], st[lg][r - (1 << lg) + 1]);\r",
			"  }\r",
			"};"
		],
		"description": "Data structure for Range minimum queries"
	},
	"Centroid": {
		"prefix": "centroid",
		"body": [
			"/**\r",
			" * Description: Finding centroid of subtree rooted at each vertex in O(N)\r",
			" * Source: self\r",
			" * Verification: https://codeforces.com/contest/685/submission/102991554\r",
			" */\r",
			"\r",
			"struct Centroid {\r",
			"  vector<vector<int>> g;\r",
			"  vector<int> c, dp, mx, pr;\r",
			"\r",
			"  void Dfs(int u, int p) {\r",
			"    pr[u] = p;\r",
			"    dp[u] = 1;\r",
			"    for (int v : g[u]) {\r",
			"      if (v == p) continue;\r",
			"      Dfs(v, u);\r",
			"      dp[u] += dp[v];\r",
			"      mx[u] = max(mx[u], dp[v]);\r",
			"    }\r",
			"  }\r",
			"\r",
			"  bool Ask(int u, int v) {\r",
			"    return ((dp[u] - dp[v]) * 2 <= dp[u] && mx[v] * 2 <= dp[u]);\r",
			"  }\r",
			"\r",
			"  void Solve (int u) {\r",
			"    if (sz(g[u]) == 0) {\r",
			"      c[u] = u;\r",
			"      return;\r",
			"    }\r",
			"    int lol = -1;\r",
			"    for (int v : g[u]) {\r",
			"      if (v == pr[u]) continue;\r",
			"      Solve(v);\r",
			"      if ((lol == -1) || (dp[lol] < dp[v])) {\r",
			"        lol = v;\r",
			"      }\r",
			"    }\r",
			"    int ce = c[lol];\r",
			"    while (!Ask(u, ce)) ce = pr[ce];\r",
			"    c[u] = ce;\r",
			"  }\r",
			"\r",
			"  vector<int> get() {\r",
			"    Dfs(0, 0);\r",
			"    Solve(0);\r",
			"    return c;\r",
			"  }\r",
			"\r",
			"  Centroid(const vector<vector<int>> g_) : g(g_) {\r",
			"    int n = sz(g);\r",
			"    c.resize(n);\r",
			"    dp.resize(n);\r",
			"    mx.resize(n);\r",
			"    pr.assign(n, -1);\r",
			"  }\r",
			"};"
		],
		"description": "Finding centroid of subtree rooted at each vertex in O(V)"
	},
	"LCA using binary lifting": {
		"prefix": "lca_binarylift",
		"body": [
			"/**\r",
			" * Various implementations of LCA\r",
			" * \r",
			" * +---------------------------------+-------------------------------+-----------------------------------------------------------------+\r",
			" * | Data Structure & Algorithm Used | Preprocessing and Query Time  | Advantage over others                                           |\r",
			" * +---------------------------------+-------------------------------+-----------------------------------------------------------------|\r",
			" * | Segment Tree (Euler tour)       | P : O(N),     Q : O(logN)     | Trivial                                                         |\r",
			" * | Sparse Table (Euler tour)       | P : O(NlogN), Q : O(1)        | Less complexity for query                                       |\r",
			" * | Binary Lifting                  | P : O(NlogN), Q : O(logN)     | Expensive, but can be used to obtain any ancestor of a node     |\r",
			" * | Farach-Colton (Bit-masking)     | P : O(N),     Q : O(1)        | Not used in CP afaik                                            |\r",
			" * +---------------------------------+-------------------------------+-----------------------------------------------------------------|\r",
			" */\r",
			"\r",
			"/**\r",
			" * Description: Finding LCA and Kth Ancestor using Binary Lifting\r",
			" * Caution:\r",
			" *    * adj must be zero indexed\r",
			" *    * root must be 0 (can be modified if required)\r",
			" * Source : https://codeforces.com/contest/519/submission/10070146\r",
			" * Verification : https://codeforces.com/contest/519/problem/E\r",
			" */\r",
			" \r",
			"struct LCA {\r",
			"  vector<vector<int>> anc;\r",
			"  vector<int> d;\r",
			"  vector<vector<int>> adj;\r",
			"  int lg;\r",
			" \r",
			"  void Dfs (int p, int v) {\r",
			"    anc[0][v] = p;\r",
			"    for (int i = 1; i < lg; i++) {\r",
			"      anc[i][v] = anc[i-1][anc[i-1][v]];\r",
			"    }\r",
			"    for (int u : adj[v]) {\r",
			"      if (u == p) continue;\r",
			"      d[u] = d[v] + 1;\r",
			"      Dfs(v, u);\r",
			"    }\r",
			"  }\r",
			" \r",
			"  int get_parent (int v, int k) {\r",
			"    for (int i = 0; i < lg; i++) {\r",
			"      if ((1 << i) & k) v = anc[i][v];\r",
			"    }\r",
			"    return v;\r",
			"  }\r",
			" \r",
			"  int lca (int u, int v) {\r",
			"    if (d[u] < d[v]) swap(u, v);\r",
			"    u = get_parent(u, d[u] - d[v]);\r",
			"    if (u == v) return u;\r",
			"    for (int i = lg - 1; i >= 0; i--) {\r",
			"      if (anc[i][u] == anc[i][v]) continue;\r",
			"      u = anc[i][u];\r",
			"      v = anc[i][v];\r",
			"    }\r",
			"    return anc[0][v];\r",
			"  }\r",
			" \r",
			"  LCA (vector<vector<int>>& g) {\r",
			"    int n = static_cast<int>(g.size());\r",
			"    int lg = static_cast<int>(ceil(log2l(static_cast<ld>(n))));\r",
			"    this->lg = lg;\r",
			"    adj = g;\r",
			"    anc.assign(lg, vector<int>(n, 0));\r",
			"    d.assign(n, 0);\r",
			"    Dfs(0, 0);\r",
			"  }\r",
			"};"
		],
		"description": "Finding LCA using binary lifting"
	},
	"LCA using RMQ": {
		"prefix": "lca",
		"body": [
			"/**\r",
			" * Various implementations of LCA\r",
			" * \r",
			" * +---------------------------------+-------------------------------+-----------------------------------------------------------------+\r",
			" * | Data Structure & Algorithm Used | Preprocessing and Query Time  | Advantage over others                                           |\r",
			" * +---------------------------------+-------------------------------+-----------------------------------------------------------------|\r",
			" * | Segment Tree (Euler tour)       | P : O(N),     Q : O(logN)     | Trivial                                                         |\r",
			" * | Sparse Table (Euler tour)       | P : O(NlogN), Q : O(1)        | Less complexity for query                                       |\r",
			" * | Binary Lifting                  | P : O(NlogN), Q : O(logN)     | Expensive, but can be used to obtain any ancestor of a node     |\r",
			" * | Farach-Colton (Bit-masking)     | P : O(N),     Q : O(1)        | Not used in CP afaik                                            |\r",
			" * +---------------------------------+-------------------------------+-----------------------------------------------------------------|\r",
			" */\r",
			"\r",
			"/**\r",
			" * Description: Computing min/max function in constant time\r",
			" * Source: tourist\r",
			" */\r",
			"\r",
			"#ifdef int\r",
			"  #undef int\r",
			"#endif\r",
			"\r",
			"template <class T, class F = function<T (const T&, const T&)>>\r",
			"struct SparseTable {\r",
			"  int n;\r",
			"  vector<vector<T>> st;\r",
			"  F func;\r",
			"\r",
			"  SparseTable () {}\r",
			"\r",
			"  SparseTable (const vector<T>& a, const F& f) : func(f) {\r",
			"    n = static_cast<int>(a.size());\r",
			"    int maxlg = 32 - __builtin_clz(n);\r",
			"    st.resize(maxlg);\r",
			"    st[0] = a;\r",
			"    for (int j = 1; j < maxlg; j++) {\r",
			"      st[j].resize(n - (1 << j) + 1);\r",
			"      for (int i = 0; i <= n - (1 << j); i++) {\r",
			"        st[j][i] = func(st[j-1][i], st[j-1][i + (1 << (j-1))]);\r",
			"      }\r",
			"    }\r",
			"  }\r",
			"\r",
			"  T get (int l, int r) const {\r",
			"    int lg = 32 - __builtin_clz(r - l + 1) - 1;\r",
			"    return func(st[lg][l], st[lg][r - (1 << lg) + 1]);\r",
			"  }\r",
			"};\r",
			"\r",
			"/**\r",
			" * Description: Answering LCA only in O(1) time with O(nlogn) pre-processing (Implemented through RMQ)\r",
			" * Source: https://cp-algorithms.com/graph/lca.html\r",
			" * Verification: https://codeforces.com/contest/29/submission/97877045\r",
			" * Caution:\r",
			" *  * int has been undefined, so have to use long long wherever necessary\r",
			" */\r",
			"\r",
			"struct LCA {\r",
			"  vector<vector<int>> g;\r",
			"  vector<int> euler; // storing euler tour of the tree\r",
			"  vector<int> first; // storing the index where a vertex first appears in euler tour\r",
			"  vector<int> depth;\r",
			"  vector<bool> mark;\r",
			"  SparseTable<int> rmq;\r",
			"\r",
			"  void Dfs (int u) {\r",
			"    mark[u] = 1;\r",
			"    first[u] = sz(euler);\r",
			"    euler.pb(u);\r",
			"    for (int v : g[u]) {\r",
			"      if (mark[v]) continue;\r",
			"      depth[v] = depth[u] + 1;\r",
			"      Dfs(v);\r",
			"      euler.pb(u);\r",
			"    }\r",
			"  }\r",
			"\r",
			"  LCA() {}\r",
			"\r",
			"  LCA (const vector<vector<int>>& adj) : g(adj) {\r",
			"    int N = sz(g);\r",
			"    first.resize(N);\r",
			"    depth.resize(N);\r",
			"    mark.resize(N);\r",
			"    Dfs(0);\r",
			"    rmq = SparseTable<int>(euler, [&] (const int& L, const int& R) {\r",
			"      return (depth[L] < depth[R])? L: R;\r",
			"    });\r",
			"  }\r",
			"\r",
			"  int lca (int u, int v) {\r",
			"    int left = first[u], right = first[v];\r",
			"    if (left > right) swap(left, right);\r",
			"    return rmq.get(left, right);\r",
			"  }\r",
			"};"
		],
		"description": "LCA using RMQ"
	},
	"LCA using segtree": {
		"prefix": "lca_seg",
		"body": [
			"/**\r",
			" * Various implementations of LCA\r",
			" * \r",
			" * +---------------------------------+-------------------------------+-----------------------------------------------------------------+\r",
			" * | Data Structure & Algorithm Used | Preprocessing and Query Time  | Advantage over others                                           |\r",
			" * +---------------------------------+-------------------------------+-----------------------------------------------------------------|\r",
			" * | Segment Tree (Euler tour)       | P : O(N),     Q : O(logN)     | Trivial                                                         |\r",
			" * | Sparse Table (Euler tour)       | P : O(NlogN), Q : O(1)        | Less complexity for query                                       |\r",
			" * | Binary Lifting                  | P : O(NlogN), Q : O(logN)     | Expensive, but can be used to obtain any ancestor of a node     |\r",
			" * | Farach-Colton (Bit-masking)     | P : O(N),     Q : O(1)        | Not used in CP afaik                                            |\r",
			" * +---------------------------------+-------------------------------+-----------------------------------------------------------------|\r",
			" */\r",
			"\r",
			"struct LCA {\r",
			"    vector<int> height, euler, first, segtree;\r",
			"    vector<bool> visited;\r",
			"    int n;\r",
			"\r",
			"    LCA(vector<vector<int>> &adj, int root = 0) {\r",
			"        n = adj.size();\r",
			"        height.resize(n);\r",
			"        first.resize(n);\r",
			"        euler.reserve(n * 2);\r",
			"        visited.assign(n, false);\r",
			"        dfs(adj, root);\r",
			"        int m = euler.size();\r",
			"        segtree.resize(m * 4);\r",
			"        build(1, 0, m - 1);\r",
			"    }\r",
			"\r",
			"    void dfs(vector<vector<int>> &adj, int node, int h = 0) {\r",
			"        visited[node] = true;\r",
			"        height[node] = h;\r",
			"        first[node] = euler.size();\r",
			"        euler.push_back(node);\r",
			"        for (auto to : adj[node]) {\r",
			"            if (!visited[to]) {\r",
			"                dfs(adj, to, h + 1);\r",
			"                euler.push_back(node);\r",
			"            }\r",
			"        }\r",
			"    }\r",
			"\r",
			"    void build(int node, int b, int e) {\r",
			"        if (b == e) {\r",
			"            segtree[node] = euler[b];\r",
			"        } else {\r",
			"            int mid = (b + e) / 2;\r",
			"            build(node << 1, b, mid);\r",
			"            build(node << 1 | 1, mid + 1, e);\r",
			"            int l = segtree[node << 1], r = segtree[node << 1 | 1];\r",
			"            segtree[node] = (height[l] < height[r]) ? l : r;\r",
			"        }\r",
			"    }\r",
			"\r",
			"    int query(int node, int b, int e, int L, int R) {\r",
			"        if (b > R || e < L)\r",
			"            return -1;\r",
			"        if (b >= L && e <= R)\r",
			"            return segtree[node];\r",
			"        int mid = (b + e) >> 1;\r",
			"\r",
			"        int left = query(node << 1, b, mid, L, R);\r",
			"        int right = query(node << 1 | 1, mid + 1, e, L, R);\r",
			"        if (left == -1) return right;\r",
			"        if (right == -1) return left;\r",
			"        return height[left] < height[right] ? left : right;\r",
			"    }\r",
			"\r",
			"    int lca(int u, int v) {\r",
			"        int left = first[u], right = first[v];\r",
			"        if (left > right)\r",
			"            swap(left, right);\r",
			"        return query(1, 0, euler.size() - 1, left, right);\r",
			"    }\r",
			"};\r",
			"\r",
			"signed main() {\r",
			"  return 0;\r",
			"}"
		],
		"description": "LCA using Segment Tree"
	},
	"Tree diameter": {
		"prefix": "diameter",
		"body": [
			"/**\r",
			" * Description: Finding the diameter of tree in O(V + E)\r",
			" * Source: Self\r",
			" */\r",
			"\r",
			"struct TD {\r",
			"  int ans = 0;\r",
			"  vector<vector<int>> g;\r",
			"\r",
			"  int Dfs (int u, int pr) {\r",
			"    pi lol = {0, 0};\r",
			"    for (int v : g[u]) {\r",
			"      if (v == pr) continue;\r",
			"      int te = Dfs(v, u);\r",
			"      if (lol.ff < te) {\r",
			"        lol.ss = lol.ff;\r",
			"        lol.ff = te;\r",
			"      } else if (lol.ss < te) {\r",
			"        lol.ss = te;\r",
			"      }\r",
			"    }\r",
			"    ans = max(ans, lol.ff + lol.ss);\r",
			"    return lol.ff + 1;\r",
			"  }\r",
			"\r",
			"  int run() {\r",
			"    Dfs(0, 0);\r",
			"    return ans;\r",
			"  }\r",
			"\r",
			"  TD(vector<vector<int>>& _g) : g(_g) {}\r",
			"};"
		],
		"description": "Finding tree diameter"
	},
	"Segment Tree": {
		"prefix": "segtree",
		"body": [
			"/**\r",
			" * Description: Template for Segment Tree without Lazy Propagation\r",
			" * How to use:\r",
			" *  SZ -> maximum length of the array (in powers of 2)\r",
			" *  init:\r",
			" *    SegTree<int, (1 << 18)> seg;\r",
			" *  operation:\r",
			" *    build  -> seg.build(a); Note: a must be zero-indexed\r",
			" *    update -> seg.update(pos, inc);\r",
			" *    query  -> seg.query(L, R);\r",
			" * Source: self\r",
			" */\r",
			"\r",
			"template <class T, int SZ>\r",
			"struct SegTree {\r",
			"  T t[2*SZ];\r",
			"\r",
			"  SegTree () {\r",
			"    // initialization\r",
			"    memset(t, 0, sizeof t);\r",
			"  }\r",
			"\r",
			"  void pull (int v) {\r",
			"    // operation\r",
			"    t[v] = t[2*v] + t[2*v+1];\r",
			"  }\r",
			"\r",
			"  void build (const vector<int>& a) {\r",
			"    assert((int)a.size() <= SZ);\r",
			"    for (int i = 0; i < (int)a.size(); i++) {\r",
			"      t[SZ + i] = a[i];\r",
			"    }\r",
			"    for (int i = SZ - 1; i >= 1; i--) {\r",
			"      pull(i);\r",
			"    }\r",
			"  }\r",
			"\r",
			"  void update (int pos, T inc, int v = 1, int tl = 1, int tr = SZ) {\r",
			"    if (tl == tr) {\r",
			"      // update operation\r",
			"      t[v] += inc;\r",
			"    } else {\r",
			"      int tm = (tl + tr) / 2;\r",
			"      if (pos <= tm) {\r",
			"        update(pos, inc, 2 * v, tl, tm);\r",
			"      } else {\r",
			"        update(pos, inc, 2 * v + 1, tm + 1, tr);\r",
			"      }\r",
			"      pull(v);\r",
			"    }\r",
			"  }\r",
			"\r",
			"  T query (int l, int r, int v = 1, int tl = 1, int tr = SZ) {\r",
			"    if (l > tr || r < tl) return 0; // out-of-index value\r",
			"    if (l <= tl && tr <= r) return t[v];\r",
			"    int tm = (tl + tr) / 2;\r",
			"    // query operation\r",
			"    return query(l, r, 2*v, tl, tm) + query(l, r, 2*v+1, tm+1, tr);\r",
			"  }\r",
			"};"
		],
		"description": "Segment Tree"
	},
	"Lazy Segment Tree": {
		"prefix": "lazysegtree",
		"body": [
			"/**\r",
			" * Description: Template for Lazy Segment Tree\r",
			" * How to use:\r",
			" *  SZ -> maximum length of the array (in powers of 2)\r",
			" *  init:\r",
			" *    LazySegTree<int, (1 << 18)> seg;\r",
			" *  operation:\r",
			" *    build  -> seg.build(a); Note: a must be zero-indexed\r",
			" *    update -> seg.update(L, R, inc);\r",
			" *    query  -> seg.query(L, R);\r",
			" * Source: self\r",
			" */\r",
			"\r",
			"template <class T, int SZ>\r",
			"struct LazySegTree {\r",
			"  T t[2*SZ], lazy[2*SZ];\r",
			"\r",
			"  LazySegTree () {\r",
			"    // initialization\r",
			"    memset(t, 0, sizeof t);\r",
			"    memset(lazy, 0, sizeof lazy);\r",
			"  }\r",
			"\r",
			"  void push (int v, int tl, int tr) {\r",
			"    if (tl != tr) {\r",
			"      lazy[2*v] += lazy[v];\r",
			"      lazy[2*v+1] += lazy[v];\r",
			"    }\r",
			"    // operation\r",
			"    t[v] += (tr - tl + 1) * lazy[v];\r",
			"    lazy[v] = 0;\r",
			"  }\r",
			"\r",
			"  void pull (int v) {\r",
			"    // operation\r",
			"    t[v] = t[2*v] + t[2*v+1];\r",
			"  }\r",
			"\r",
			"  void build (const vector<int>& a) {\r",
			"    assert((int)a.size() <= SZ);\r",
			"    for (int i = 0; i < (int)a.size(); i++) {\r",
			"      t[SZ + i] = a[i];\r",
			"    }\r",
			"    for (int i = SZ - 1; i >= 1; i--) {\r",
			"      pull(i);\r",
			"    }\r",
			"  }\r",
			"\r",
			"  void update (int l, int r, T inc, int v = 1, int tl = 1, int tr = SZ) {\r",
			"    push(v, tl, tr);\r",
			"    if (l > tr || r < tl) return;\r",
			"    if (l <= tl && tr <= r) {\r",
			"      lazy[v] += inc;\r",
			"      push(v, tl, tr);\r",
			"    } else {\r",
			"      int tm = (tl + tr) / 2;\r",
			"      update(l, r, inc, 2*v, tl, tm);\r",
			"      update(l, r, inc, 2*v+1, tm+1, tr);\r",
			"      pull(v);\r",
			"    }\r",
			"  }\r",
			"\r",
			"  T query (int l, int r, int v = 1, int tl = 1, int tr = SZ) {\r",
			"    push(v, tl, tr);\r",
			"    if (l > tr || r < tl) return 0; // out-of-index value\r",
			"    if (l <= tl && tr <= r) return t[v];\r",
			"    int tm = (tl + tr) / 2;\r",
			"    // operation\r",
			"    return query(l, r, 2*v, tl, tm) + query(l, r, 2*v+1, tm+1, tr);\r",
			"  }\r",
			"};"
		],
		"description": "Lazy Segment Tree"
	},
	"Trie of strings": {
		"prefix": "trie",
		"body": [
			"const int maxn = 1e5 + 10;\r",
			"\r",
			"struct Node {\r",
			"  int v;\r",
			"  int nxt[26];\r",
			"} lt[maxn * 26];\r",
			"\r",
			"struct Trie {\r",
			"  /**\r",
			"   * Decription: Trie data structure for strings containing only lower case letters\r",
			"   *             (Can be modified of other types of strings as well)\r",
			"   * Source: self\r",
			"   * Verification: Not done yet\r",
			"   */\r",
			"\r",
			"  int tot = 0;\r",
			"\r",
			"  int newNode() {\r",
			"    lt[tot].v = 0;\r",
			"    for (int i = 0; i < 26; i++) {\r",
			"      lt[tot].nxt[i] = -1;\r",
			"    }\r",
			"    return tot++;\r",
			"  }\r",
			"\r",
			"  Trie() {}\r",
			"\r",
			"  void update(int rt, const string& s, int v) {\r",
			"    for (int i = 0; i < sz(s); i++) {\r",
			"      int id = s[i] - 'a';\r",
			"      if (lt[rt].nxt[id] == -1) {\r",
			"        lt[rt].nxt[id] = newNode();\r",
			"      }\r",
			"      rt = lt[rt].nxt[id];\r",
			"      lt[rt].v += v;\r",
			"    }\r",
			"  }\r",
			"  \r",
			"  bool search (int rt, const string& s) {\r",
			"    for (int i = 0; i < sz(s); i++) {\r",
			"      int id = s[i] - 'a';\r",
			"      int crt = lt[rt].nxt[id];\r",
			"      if (crt == -1 || lt[crt].v <= 0) return false;\r",
			"      rt = crt;\r",
			"    }\r",
			"    return true;\r",
			"  }\r",
			"};"
		],
		"description": "Trie of strings"
	},
	"Trie of integers": {
		"prefix": "trie_int",
		"body": [
			"template <int SZ>\r",
			"struct IntegerTrie {\r",
			"  /**\r",
			"   * Description: Trie data structure for bit manipulation\r",
			"   * Source: Self\r",
			"   */\r",
			"\r",
			"  struct Node {\r",
			"    int v;\r",
			"    int nxt[2];\r",
			"  } lt[40 * SZ];\r",
			"\r",
			"  int tot = 0;\r",
			"\r",
			"  int newNode() {\r",
			"    lt[tot].v = 0;\r",
			"    lt[tot].nxt[0] = -1;\r",
			"    lt[tot].nxt[1] = -1;\r",
			"    return tot++;\r",
			"  } \r",
			"\r",
			"  IntegerTrie() {}\r",
			"\r",
			"  void update (int rt, int x, int v) {\r",
			"    for (int i = 31; i >= 0; i--) {\r",
			"      int id = (x >> i) & 1;\r",
			"      if (lt[rt].nxt[id] == -1) {\r",
			"        lt[rt].nxt[id] = newNode();\r",
			"      }\r",
			"      rt = lt[rt].nxt[id];\r",
			"      lt[rt].v += v;\r",
			"    }\r",
			"  }\r",
			"\r",
			"  int query (int rt, int x) {\r",
			"    int ans = 0;\r",
			"    for (int i = 31; i >= 0; i--) {\r",
			"      int id = (x >> i) & 1;\r",
			"      int crt = lt[rt].nxt[id ^ 1];\r",
			"      if (crt != -1 && lt[crt].v > 0) ans |= (1ll << i);\r",
			"      else crt = lt[rt].nxt[id];\r",
			"      rt = crt;\r",
			"    }\r",
			"    return ans;\r",
			"  }\r",
			"};"
		],
		"description": "Trie of integers"
	},
	"Z function": {
		"prefix": "z_function",
		"body": [
			"vector<int> z_function(const string& s) {\r",
			"  int n = (int) s.length();\r",
			"  vector<int> z(n);\r",
			"  for (int i = 1, l = 0, r = 0; i < n; ++i) {\r",
			"    if (i <= r)\r",
			"      z[i] = min (r - i + 1, z[i - l]);\r",
			"    while (i + z[i] < n && s[z[i]] == s[i + z[i]])\r",
			"      ++z[i];\r",
			"    if (i + z[i] - 1 > r)\r",
			"        l = i, r = i + z[i] - 1;\r",
			"  }\r",
			"  return z;\r",
			"}"
		],
		"description": "Z functions for strings"
	},
	"Prefix function": {
		"prefix": "prefix_function",
		"body": [
			"vector<int> prefix_function (const string& s) {\r",
			"  int n = (int) s.length();\r",
			"  vector<int> prefix(n, 0);\r",
			"  for (int i = 1; i < n; i++) {\r",
			"    int j = prefix[i - 1];\r",
			"    while (j > 0 && s[i] != s[j]) j = prefix[j - 1];\r",
			"    if (s[i] == s[j]) j++;\r",
			"    prefix[i] = j;\r",
			"  }\r",
			"  return prefix;\r",
			"}"
		],
		"description": "Prefix function for strings"
	},
	"Phi function": {
		"prefix": "phi",
		"body": [
			"/**\r",
			" * Determing the totient function, phi(n) for given n, in sqrt complexity\r",
			" */\r",
			"\r",
			"int phi (int n) {\r",
			"  int res = n;\r",
			"  for (int i = 2; i*i <= n; i++) {\r",
			"    if (n % i == 0) {\r",
			"      while (n % i == 0) n /= i;\r",
			"      res -= res/i;\r",
			"    }\r",
			"  }\r",
			"  if (n > 1) res -= res/n;\r",
			"  return res;\r",
			"}"
		],
		"description": "Euler totient function"
	},
	"Phi function from 1 to N": {
		"prefix": "phi_1_to_n",
		"body": [
			"/**\r",
			" * Evaluates totient function of 1 .. n in O(nlglgn)\r",
			" */\r",
			"\r",
			"vector<int> sieve (int n) {\r",
			"  vector<int> phi(n + 1);\r",
			"  phi[0] = 0;\r",
			"  phi[1] = 1;\r",
			"  for (int i = 2; i <= n; i++) phi[i] = i;\r",
			"  for (int i = 2; i <= n; i++) if (phi[i] == i) {\r",
			"    for (int j = i; j <= n; j += i) phi[j] -= phi[j] / i;\r",
			"  }\r",
			"  return phi;\r",
			"}"
		],
		"description": "Euler totient function for 1 to N"
	},
	"Smallest prime factor": {
		"prefix": "spf",
		"body": [
			"// Computing smallest prime factor as sieve in O(nloglogn)\r",
			"// Largest prime factor can be computed by removing (a[j] == 0) condition\r",
			"vector<int> spf(int n) {\r",
			"  n++;\r",
			"  vector<int> a(n);\r",
			"  a[1] = 1;\r",
			"  for (int i = 2; i < n; i++) {\r",
			"    if (a[i] == 0) {\r",
			"      a[i]  = i;\r",
			"      for (int j = 2 * i; j < n; j += i) {\r",
			"        if (a[j] == 0) a[j] = i;\r",
			"      }\r",
			"    }\r",
			"  }\r",
			"  return a;\r",
			"}"
		],
		"description": "Smallest prime factor"
	},
	"Generate primes upto N": {
		"prefix": "primes",
		"body": [
			"// Get primes not greater than n in O(nloglogn)\r",
			"vector<int> getprimes(int n) {\r",
			"  vector<int> p;\r",
			"  vector<bool> is(n + 1, 1);\r",
			"  for (int i = 2; i <= n; i++) {\r",
			"    if (is[i]) {\r",
			"      p.pb(i);\r",
			"      for (int j = 2 * i; j <= n; j += i) is[j] = 0;\r",
			"    }\r",
			"  }\r",
			"  return p;\r",
			"}"
		],
		"description": "Generate primes upto N"
	},
	"Template code": {
		"prefix": "make",
		"body": [
			"#include <bits/stdc++.h>\r",
			"#include <ext/pb_ds/assoc_container.hpp> \r",
			"#include <ext/pb_ds/tree_policy.hpp> \r",
			"using namespace __gnu_pbds;\r",
			"using namespace std;\r",
			"\r",
			"string to_string(const string& s) {return '\"' + s + '\"';}\r",
			"string to_string(const char* s) {return to_string((string) s);}\r",
			"string to_string(bool b) {return (b ? \"true\" : \"false\");}\r",
			"string to_string(vector<bool> v) {bool first = true;string res = \"{\";for (int i = 0; i < static_cast<int>(v.size()); i++) {if (!first) {res += \", \";}first = false;res += to_string(v[i]);}res += \"}\";return res;}\r",
			"template <size_t N> string to_string(bitset<N> v) {string res = \"\";for (size_t i = 0; i < N; i++) {res += static_cast<char>('0' + v[i]);}return res;}\r",
			"template <class A, class B> string to_string(pair<A, B> p) {return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";}\r",
			"template <class A, class B, class C> string to_string(tuple<A, B, C> p) {return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";}\r",
			"template <class A, class B, class C, class D> string to_string(tuple<A, B, C, D> p) {return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";}\r",
			"template <class A> string to_string(A v) {bool first = true;string res = \"{\";for (const auto &x : v) {if (!first) {res += \", \";}first = false;res += to_string(x);}res += \"}\";return res;}\r",
			"\r",
			"template <class Arg1>\r",
			"void __f(const char* name, Arg1&& arg1){\r",
			"  cerr << name << \" : \" << to_string(arg1) << \"\\n\";\r",
			"}\r",
			"\r",
			"template <class Arg1, class... Args>\r",
			"void __f(const char* names, Arg1&& arg1, Args&&... args){\r",
			"  const char* comma = strchr(names + 1, ',');\r",
			"  cerr.write(names, comma - names) << \" : \" << to_string(arg1) <<\" | \";\r",
			"  __f(comma+1, args...);\r",
			"}\r",
			"\r",
			"#ifdef LOCAL\r",
			"#define debug(...) __f(#__VA_ARGS__, __VA_ARGS__)\r",
			"#else\r",
			"#define debug(...) 69\r",
			"#endif\r",
			"\r",
			"#define int long long\r",
			"#define sz(x) (int)x.size()\r",
			"#define all(x) (x).begin(), (x).end()\r",
			"#define pb push_back\r",
			"#define eb emplace_back\r",
			"#define ff first\r",
			"#define ss second\r",
			"#define pi pair<int, int>\r",
			"\r",
			"template <class L, class R> istream& operator>> (istream& is, pair<L, R>& P) { return is >> P.ff >> P.ss; }\r",
			"template <class T> istream& operator>> (istream& is, vector<T>& V) { for (auto& e : V) is >> e; return is; }\r",
			"template <class L, class R> ostream& operator<< (ostream& os, pair<L, R>& P) { return os << P.ff << \" \" << P.ss; }\r",
			"template <class T> ostream& operator<< (ostream& os, vector<T>& V) { for (auto& e : V) os << e << \" \"; return os; }\r",
			"template <class T> void remove_dups (vector<T>& V) { V.erase(unique(V.begin(), V.end()), V.end()); }\r",
			"\r",
			"auto seed = chrono::high_resolution_clock::now().time_since_epoch().count();\r",
			"mt19937_64 rng(seed);\r",
			"inline long long gcd(long long a, long long b) { long long r; while (b) { r = a % b; a = b; b = r;} return a; }\r",
			"inline long long ceil_div(long long a, long long b) { return a / b + ((a ^ b) > 0 && a % b != 0); }\r",
			"inline long long rnd(long long l, long long r) { uniform_int_distribution<long long> dis(l, r); return dis(rng); }\r",
			"\r",
			"const int infi = 2e9;\r",
			"const long long infl = 4e18;\r",
			"const int md = 998244353;\r",
			"const double PI = 3.14159265358979323846;\r",
			"const double eps = 1e-8;\r",
			"\r",
			"template <class T>\r",
			"struct cmp {\r",
			"  bool operator() (const T& x, const T& y) const {\r",
			"    return x > y;\r",
			"  }\r",
			"  typedef T first_argument_type;\r",
			"  typedef T second_argument_type;\r",
			"  typedef bool result_type;\r",
			"};\r",
			"\r",
			"signed main() {\r",
			"  ios_base::sync_with_stdio(false);\r",
			"  cin.tie(nullptr);\r",
			"  cout << fixed << setprecision(10);\r",
			"  return 0;\r",
			"}"
		],
		"description": "Template code for competitive programming"
	},
	"Union Find data structure": {
		"prefix": "dsu",
		"body": [
			"struct dsu {\r",
			"  vector<int> parent, size;\r",
			" \r",
			"  int find (int v) {\r",
			"    if (v == parent[v]) return v;\r",
			"    return parent[v] = find(parent[v]);\r",
			"  }\r",
			" \r",
			"  bool ask (int a, int b) {\r",
			"    a = find(a); b = find(b);\r",
			"    return (a == b);\r",
			"  }\r",
			" \r",
			"  void join (int a, int b) {\r",
			"    a = find(a);\r",
			"    b = find(b);\r",
			"    if (a != b) {\r",
			"      if (size[a] < size[b]) swap(a, b);\r",
			"      parent[b] = a;\r",
			"      size[a] += size[b];\r",
			"    }\r",
			"  }\r",
			"\r",
			"  dsu() {}\r",
			" \r",
			"  dsu (int n) {\r",
			"    parent.resize(n);\r",
			"    size.assign(n, 1);\r",
			"    iota(all(parent), 0LL);\r",
			"  }\r",
			"};"
		],
		"description": "Data structure for carrying out union-find operations efficiently"
	},
	"Compilation flags": {
		"prefix": "compile",
		"body": [
			"doskey c = g++ -pedantic -std=c++17 -DLOCAL -O2 -Wall -Wl,--stack=268435456 $*.cpp -D_GLIBCXX_DEBUG -D_GLIBCXX_DEBUG_PEDANTIC -Wshadow -Wfloat-equal\r",
			"cd Documents\\cpp\\contest"
		],
		"description": "Compilation flags for C"
	},
	"INT128 Read and Write": {
		"prefix": "print_int128",
		"body": [
			"#ifdef __SIZEOF_INT128__\r",
			"ostream& operator << (ostream &os, __int128 const& value){\r",
			"    static char buffer[64];\r",
			"    int index = 0;\r",
			"    __uint128_t T = (value < 0) ? (-(value + 1)) + __uint128_t(1) : value;\r",
			"    if (value < 0) \r",
			"        os << '-';\r",
			"    else if (T == 0)\r",
			"        return os << '0';\r",
			"    for(; T > 0; ++index){\r",
			"        buffer[index] = static_cast<char>('0' + (T % 10));\r",
			"        T /= 10;\r",
			"    }    \r",
			"    while(index > 0)\r",
			"        os << buffer[--index];\r",
			"    return os;\r",
			"}\r",
			"istream& operator >> (istream& is, __int128& T){\r",
			"    static char buffer[64];\r",
			"    is >> buffer;\r",
			"    size_t len = strlen(buffer), index = 0;\r",
			"    T = 0; int mul = 1;\r",
			"    if (buffer[index] == '-')\r",
			"        ++index, mul *= -1;\r",
			"    for(; index < len; ++index)\r",
			"        T = T * 10 + static_cast<int>(buffer[index] - '0');\r",
			"    T *= mul;    \r",
			"    return is;\r",
			"}\r",
			"#endif"
		],
		"description": "Read and write utility for __int128"
	},
	"2D Points": {
		"prefix": "point",
		"body": [
			"template <class T>\r",
			"struct Point {\r",
			"  T x, y;\r",
			"  Point() {}\r",
			"  Point(T x_, T y_) : x(x_), y(y_) {}\r",
			"  Point& operator+=(const Point& oth) {\r",
			"    x += oth.x;\r",
			"    y += oth.y;\r",
			"    return *this;\r",
			"  }\r",
			"  Point& operator-=(const Point& oth) {\r",
			"    x -= oth.x;\r",
			"    y -= oth.y;\r",
			"    return *this;\r",
			"  }\r",
			"  Point& operator*=(const T& k) {\r",
			"    x *= k;\r",
			"    y *= k;\r",
			"    return *this;\r",
			"  }\r",
			"  Point& operator/=(const T& k) {\r",
			"    x /= k;\r",
			"    y /= k;\r",
			"    return *this;\r",
			"  }\r",
			"  Point operator+(const Point& oth) const {\r",
			"    return Point(*this) += oth;\r",
			"  }\r",
			"  Point operator-(const Point& oth) const {\r",
			"    return Point(*this) -= oth;\r",
			"  }\r",
			"  Point operator*(const T& k) const {\r",
			"    return Point(*this) *= k;\r",
			"  }\r",
			"  Point operator/(const T& k) const {\r",
			"    return Point(*this) /= k;\r",
			"  }\r",
			"  T dot(const Point& oth) const {\r",
			"    return x * oth.x + y * oth.y;\r",
			"  }\r",
			"  T cross(const Point& oth) const {\r",
			"    return x * oth.y - y * oth.x;\r",
			"  }\r",
			"  T cross(const Point& P, const Point& Q) const {\r",
			"    return (P - *this).cross(Q - *this);\r",
			"  }\r",
			"  friend Point operator*(T k, Point self) {\r",
			"    return self * k;\r",
			"  }\r",
			"};"
		],
		"description": "Handling 2D points in C++"
	},
	"2D lines (interger case)": {
		"prefix": "line_int",
		"body": [
			"/**\r",
			" * Description: Handling Lines in 2D geometry (for integer case)\r",
			" * Caution: \r",
			" * * include 'Point' module as well\r",
			" */\r",
			"\r",
			"long long det(long long a, long long b, long long c, long long d) {\r",
			"  return a * d - b * c;\r",
			"}\r",
			"\r",
			"struct Line {\r",
			"  long long a, b, c;\r",
			"  Line() {}\r",
			"  Line(long long a_, long long b_, long long c_) : a(a_), b(b_), c(c_) {}\r",
			"  Line(const Point<long long>& P, const Point<long long>& Q) {\r",
			"    a = P.y - Q.y;\r",
			"    b = Q.x - P.x;\r",
			"    c = -1LL * (a * P.x + b * P.y);\r",
			"    long long g = gcd(gcd(abs(a), abs(b)), abs(c));\r",
			"    a /= g; b /= g; c /= g;\r",
			"    if (a < 0 || (a == 0 || b < 0)) {\r",
			"      a *= -1; b *= -1; c *= -1;\r",
			"    }\r",
			"  }\r",
			"\r",
			"  bool operator==(const Line& oth) {\r",
			"    return (a == oth.a && b == oth.b && c == oth.c);\r",
			"  }\r",
			"\r",
			"  bool isect(const Line& oth) {\r",
			"    long long z = det(a, b, oth.a, oth.b);\r",
			"    if (z == 0) return false;\r",
			"    return true;\r",
			"  }\r",
			"\r",
			"  tuple<long long, long long, long long> isect_point(const Line& oth) {\r",
			"    long long z = det(a, b, oth.a, oth.b);\r",
			"    long long x = -det(c, b, oth.c, oth.b);\r",
			"    long long y = -det(a, c, oth.a, oth.c);\r",
			"    return make_tuple(x, y, z);\r",
			"  }\r",
			"\r",
			"  friend string to_string(const Line& L) {\r",
			"    return to_string(make_tuple(L.a, L.b, L.c));\r",
			"  }\r",
			"};"
		],
		"description": "Handling integer case of 2D lines"
	},
	"2D lines (real case)": {
		"prefix": "line_double",
		"body": [
			"/**\r",
			" * Description: Handling Lines in 2D geometry (for real case)\r",
			" * Caution: \r",
			" * * include Point as well\r",
			" */\r",
			"\r",
			"double det(double a, double b, double c, double d) {\r",
			"  return a * d - b * c;\r",
			"}\r",
			"\r",
			"struct Line {\r",
			"  double a, b, c;\r",
			"  Line() {}\r",
			"  Line(double a_, double b_, double c_) : a(a_), b(b_), c(c_) {}\r",
			"  Line(const Point<double>& P, const Point<double>& Q) {\r",
			"    a = P.y - Q.y;\r",
			"    b = Q.x - P.x;\r",
			"    c = -1.0 * (a * P.x + b * P.y);\r",
			"\r",
			"    double z = (double) sqrt(a * a + b * b);\r",
			"    if (z > eps) {\r",
			"      a /= z; b /= z; c /= z;\r",
			"    }\r",
			"    if (a < (-eps) || (abs(a) < eps && b < (-eps))) {\r",
			"      a *= -1; b *= -1; c *= -1;\r",
			"    }\r",
			"  }\r",
			"\r",
			"  bool operator==(const Line& oth) {\r",
			"    double A = abs(det(a, b, oth.a, oth.b));\r",
			"    double B = abs(det(a, c, oth.a, oth.c));\r",
			"    double C = abs(det(b, c, oth.b, oth.c));\r",
			"    return (A < eps && B < eps && C < eps);\r",
			"  }\r",
			"\r",
			"  bool isect(const Line& oth) {\r",
			"    double z = det(a, b, oth.a, oth.b);\r",
			"    if (abs(z) < eps) return false;\r",
			"    return true;\r",
			"  }\r",
			"\r",
			"  Point isect_point(const Line& oth) {\r",
			"    double z = det(a, b, oth.a, oth.b);\r",
			"    double x = -det(c, b, oth.c, oth.b) / z;\r",
			"    double y = -det(a, c, oth.a, oth.c) / z;\r",
			"    return Point(x, y);\r",
			"  }\r",
			"\r",
			"  friend string to_string(const Line& L) {\r",
			"    return to_string(make_tuple(L.a, L.b, L.c));\r",
			"  }\r",
			"};\r",
			""
		],
		"description": "Handling real case of 2D lines"
	},
	"Printing matrices and large integers": {
		"prefix": "pr",
		"body": [
			"template <class T, const int SZ>\r",
			"void pr(T v[][SZ], int n, int m) {\r",
			"  for (int i = 0; i < n; i++) {\r",
			"    for (int j = 0; j < m; j++) {\r",
			"      cout << v[i][j] << \"\\t\";\r",
			"    }\r",
			"    cout << \"\\n\";\r",
			"  }\r",
			"}\r",
			"\r",
			"#ifdef __SIZEOF_INT128__\r",
			"ostream& operator << (ostream &os, __int128 const& value){\r",
			"  static char buffer[64];\r",
			"  int index = 0;\r",
			"  __uint128_t T = (value < 0) ? (-(value + 1)) + __uint128_t(1) : value;\r",
			"  if (value < 0) \r",
			"    os << '-';\r",
			"  else if (T == 0)\r",
			"    return os << '0';\r",
			"  for(; T > 0; ++index){\r",
			"    buffer[index] = static_cast<char>('0' + (T % 10));\r",
			"    T /= 10;\r",
			"  }    \r",
			"  while(index > 0)\r",
			"    os << buffer[--index];\r",
			"  return os;\r",
			"}\r",
			"istream& operator >> (istream& is, __int128& T){\r",
			"  static char buffer[64];\r",
			"  is >> buffer;\r",
			"  size_t len = strlen(buffer), index = 0;\r",
			"  T = 0; int mul = 1;\r",
			"  if (buffer[index] == '-')\r",
			"    ++index, mul *= -1;\r",
			"  for(; index < len; ++index)\r",
			"    T = T * 10 + static_cast<int>(buffer[index] - '0');\r",
			"  T *= mul;    \r",
			"  return is;\r",
			"}\r",
			"#endif"
		],
		"description": "Debugging matrices and large integers in C++"
	},
	"String hashing": {
		"prefix": "stringhash",
		"body": [
			"#ifdef int\r",
			"  #undef int\r",
			"#endif\r",
			"\r",
			"template <int MOD_> struct modnum {\r",
			"  static constexpr int MOD = MOD_;\r",
			"  static_assert(MOD_ > 0, \"MOD must be positive\");\r",
			"private:\r",
			"  using ll = long long;\r",
			"  int v;\r",
			"  static int minv(int a, int m) {\r",
			"    a %= m;\r",
			"    assert(a);\r",
			"    return a == 1 ? 1 : int(m - ll(minv(m, a)) * ll(m) / a);\r",
			"  }\r",
			"public:\r",
			"  modnum() : v(0) {}\r",
			"  modnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\r",
			"  explicit operator int() const { return v; }\r",
			"  friend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }\r",
			"  friend std::istream& operator >> (std::istream& in, modnum& n) { ll v_; in >> v_; n = modnum(v_); return in; }\r",
			"  friend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\r",
			"  friend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\r",
			"  modnum inv() const {\r",
			"    modnum res;\r",
			"    res.v = minv(v, MOD);\r",
			"    return res;\r",
			"  }\r",
			"  friend modnum inv(const modnum& m) { return m.inv(); }\r",
			"  modnum neg() const {\r",
			"    modnum res;\r",
			"    res.v = v ? MOD-v : 0;\r",
			"    return res;\r",
			"  }\r",
			"  friend modnum neg(const modnum& m) { return m.neg(); }\r",
			"  modnum operator- () const {\r",
			"    return neg();\r",
			"  }\r",
			"  modnum operator+ () const {\r",
			"    return modnum(*this);\r",
			"  }\r",
			"  modnum& operator ++ () {\r",
			"    v ++;\r",
			"    if (v == MOD) v = 0;\r",
			"    return *this;\r",
			"  }\r",
			"  modnum& operator -- () {\r",
			"    if (v == 0) v = MOD;\r",
			"    v --;\r",
			"    return *this;\r",
			"  }\r",
			"  modnum& operator += (const modnum& o) {\r",
			"    v += o.v;\r",
			"    if (v >= MOD) v -= MOD;\r",
			"    return *this;\r",
			"  }\r",
			"  modnum& operator -= (const modnum& o) {\r",
			"    v -= o.v;\r",
			"    if (v < 0) v += MOD;\r",
			"    return *this;\r",
			"  }\r",
			"  modnum& operator *= (const modnum& o) {\r",
			"    v = int(ll(v) * ll(o.v) % MOD);\r",
			"    return *this;\r",
			"  }\r",
			"  modnum& operator /= (const modnum& o) {\r",
			"    return *this *= o.inv();\r",
			"  }\r",
			"  friend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }\r",
			"  friend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }\r",
			"  friend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\r",
			"  friend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\r",
			"  friend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\r",
			"  friend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\r",
			"  friend string to_string (const modnum& a) { return to_string(int(a)); }\r",
			"};\r",
			"\r",
			"using Mint = modnum<md>;\r",
			"\r",
			"vector<Mint> fact(1, 1);\r",
			"vector<Mint> inv_fact(1, 1);\r",
			"\r",
			"template<class T, class U>\r",
			"T power(const T& a, const U& b) {\r",
			"  assert(b >= 0);\r",
			"  T x = a, res = 1;\r",
			"  U p = b;\r",
			"  while (p > 0) {\r",
			"    if (p & 1) res *= x;\r",
			"    x *= x;\r",
			"    p >>= 1;\r",
			"  }\r",
			"  return res;\r",
			"}\r",
			" \r",
			"Mint C(int n, int k) {\r",
			"  if (k < 0 || k > n) {\r",
			"    return 0;\r",
			"  }\r",
			"  while ((int) fact.size() < n + 1) {\r",
			"    fact.push_back(fact.back() * (int) fact.size());\r",
			"    inv_fact.push_back(1 / fact.back());\r",
			"  }\r",
			"  return fact[n] * inv_fact[k] * inv_fact[n - k];\r",
			"}\r",
			"\r",
			"Mint p = 67;\r",
			"Mint pinv = p.inv();\r",
			"vector<Mint> rdx(1, 1), rdxi(1, 1);\r",
			"\r",
			"map<char, int> M;\r",
			"\r",
			"bool pre_calc = false;\r",
			"\r",
			"void pre() {\r",
			"  int i = 1;\r",
			"  for (char j = '0'; j <= '9'; j++) M[j] = i++;\r",
			"  for (char j = 'A'; j <= 'Z'; j++) M[j] = i++;\r",
			"  for (char j = 'a'; j <= 'z'; j++) M[j] = i++;\r",
			"}\r",
			"\r",
			"struct Hash {\r",
			"  string s;\r",
			"  int length;\r",
			"  vector<Mint> pref, suf;\r",
			"\r",
			"  void fillprefHash() {\r",
			"    Mint h = 0;\r",
			"    for (int i = 0; i < length; i++) {\r",
			"      h = (h + rdx[i] * M[s[i]]);\r",
			"      pref[i] = h;\r",
			"    }\r",
			"  }\r",
			"\r",
			"  void fillsufHash() {\r",
			"    Mint h = 0;\r",
			"    for (int i = 0; i < length; i++) {\r",
			"      h = (h + rdx[i] * M[s[length - 1 - i]]);\r",
			"      suf[i] = h;\r",
			"    }\r",
			"  }\r",
			"\r",
			"  Hash() {}\r",
			"\r",
			"  Hash(string _s) : s(_s){\r",
			"    if (!pre_calc) {\r",
			"      pre_calc = 1;\r",
			"      pre();\r",
			"    }\r",
			"    length = sz(s);\r",
			"    while (sz(rdx) < length) {\r",
			"      rdx.pb(rdx.back() * p);\r",
			"      rdxi.pb(rdxi.back() * pinv);\r",
			"    }\r",
			"    pref.assign(length, 0);\r",
			"    suf.assign(length, 0);\r",
			"    fillprefHash();\r",
			"    fillsufHash();\r",
			"  }\r",
			"\r",
			"  Mint fwd (int i, int j) {\r",
			"    Mint left = (i != 0)? pref[i - 1]: 0;\r",
			"    Mint right = pref[j];\r",
			"    Mint h = right - left;\r",
			"    return h * rdxi[i];\r",
			"  }\r",
			"\r",
			"  Mint bwd (int i, int j) {\r",
			"    swap(i, j);\r",
			"    i = length - 1 - i;\r",
			"    j = length - 1 - j;\r",
			"    Mint left = (i != 0)? suf[i - 1]: 0;\r",
			"    Mint right = suf[j];\r",
			"    Mint h = right - left;\r",
			"    return h * rdxi[i];\r",
			"  }\r",
			"};"
		],
		"description": "RK-hashing of strings"
	},
	"Debugger": {
		"prefix": "debug",
		"body": [
			"string to_string(const string& s) {return '\"' + s + '\"';}\r",
			"string to_string(const char* s) {return to_string((string) s);}\r",
			"string to_string(bool b) {return (b ? \"true\" : \"false\");}\r",
			"string to_string(vector<bool> v) {bool first = true;string res = \"{\";for (int i = 0; i < static_cast<int>(v.size()); i++) {if (!first) {res += \", \";}first = false;res += to_string(v[i]);}res += \"}\";return res;}\r",
			"template <size_t N> string to_string(bitset<N> v) {string res = \"\";for (size_t i = 0; i < N; i++) {res += static_cast<char>('0' + v[i]);}return res;}\r",
			"template <class A, class B> string to_string(pair<A, B> p) {return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";}\r",
			"template <class A, class B, class C> string to_string(tuple<A, B, C> p) {return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";}\r",
			"template <class A, class B, class C, class D> string to_string(tuple<A, B, C, D> p) {return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";}\r",
			"template <class A> string to_string(A v) {bool first = true;string res = \"{\";for (const auto &x : v) {if (!first) {res += \", \";}first = false;res += to_string(x);}res += \"}\";return res;}\r",
			"\r",
			"template <class Arg1>\r",
			"void __f(const char* name, Arg1&& arg1){\r",
			"  cerr << name << \" : \" << to_string(arg1) << \"\\n\";\r",
			"}\r",
			"\r",
			"template <class Arg1, class... Args>\r",
			"void __f(const char* names, Arg1&& arg1, Args&&... args){\r",
			"  const char* comma = strchr(names + 1, ',');\r",
			"  cerr.write(names, comma - names) << \" : \" << to_string(arg1) <<\" | \";\r",
			"  __f(comma+1, args...);\r",
			"}\r",
			"\r",
			"#ifdef LOCAL\r",
			"#define debug(...) __f(#__VA_ARGS__, __VA_ARGS__)\r",
			"#else\r",
			"#define debug(...) 69\r",
			"#endif"
		],
		"description": "Debugger for Competitive Programming"
	},
	"Simple": {
		"prefix": "simple",
		"body": [
			"#include <bits/stdc++.h>\r",
			"\r",
			"using namespace std;\r",
			"\r",
			"int main() {\r",
			"  return 0;\r",
			"}"
		],
		"description": "Simple template"
	}
}
